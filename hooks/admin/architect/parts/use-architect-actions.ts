'use client';

import { type ArchitectState, INITIAL_ARCHITECT_STATE } from '@/lib/domain/architect';
import { compileDiagnosticProbe } from '@/lib/actions/admin/architect-actions';
import { useRouter } from 'next/navigation';

interface UseArchitectActionsProps {
    state: ArchitectState;
    setState: React.Dispatch<React.SetStateAction<ArchitectState>>;
    examTitle: string;
    setMessages: React.Dispatch<React.SetStateAction<any[]>>;
    setInput: (val: string) => void;
    setIsLoading: (val: boolean) => void;
    onProbeGenerated?: (probeId: string, metadata: any) => void;
}

export function useArchitectActions({
    state,
    setState,
    examTitle,
    setMessages,
    setInput,
    setIsLoading,
    onProbeGenerated
}: UseArchitectActionsProps) {
    const router = useRouter();

    const handleGeneratePrototypes = async () => {
        setState(prev => ({ ...prev, isGenerating: true }));
        try {
            const { generatePrototypes } = await import('@/lib/actions/admin/architect-actions');
            const result = await generatePrototypes(state);
            if (result.success && result.prototypes) {
                setState(prev => ({
                    ...prev,
                    isGenerating: false,
                    context: { ...prev.context, prototypes: result.prototypes }
                }));
            } else {
                throw new Error(result.error || "Falla en la generación de prototipos");
            }
        } catch (error: any) {
            console.error("[useArchitectActions] Prototype generation error:", error);
            setState(prev => ({ ...prev, isGenerating: false }));
            alert(error.message || "No se pudo generar los prototipos.");
        }
    };

    const handleGenerate = async () => {
        if (!state.readiness.isValid) return;
        setState(prev => ({ ...prev, isGenerating: true }));
        try {
            const result = await compileDiagnosticProbe(state);
            if (result.success && 'probeId' in result && result.probeId) {
                setState(prev => ({
                    ...prev,
                    isGenerating: false,
                    generatedProbeId: result.probeId
                }));
                if (onProbeGenerated) {
                    onProbeGenerated(result.probeId, {
                        title: (result as any).stem || state.context.subject || 'Sonda de Diagnóstico',
                        misconceptionIds: state.context.identifiedMisconceptions?.map(m => m.competencyId || m.error) || [],
                        options: (result as any).options
                    });
                }

                // HOTFIX: Inject the generated probe into the local state so it gets carried over to the snapshot
                // This bridges the gap between SQL Persistence (compileDiagnosticProbe) and JSONB Snapshot (publishExam)
                const generatedQuestion = {
                    id: result.probeId,
                    type: 'CBM',
                    stem: (result as any).stem,
                    options: ((result as any).options || []).map((o: any) => ({
                        id: o.id || crypto.randomUUID(),
                        content: o.content, // Fix property name from text to content to match state interface
                        isCorrect: o.isCorrect || o.is_correct || false,
                        rationale: o.feedback || "Generated by AI" // Add required field
                    })),
                    competencyId: result.competencyId,
                    pedagogicalReasoning: "Generated via Calibration Probe Compiler" // Add required field
                };

                setState(prev => ({
                    ...prev,
                    context: {
                        ...prev.context,
                        prototypes: [
                            ...(prev.context.prototypes || []),
                            generatedQuestion
                        ] as any[]
                    }
                }));
            } else {
                throw new Error(result.error || "Falla en la compilación");
            }
        } catch (error: any) {
            console.error("[useArchitectActions] Generation error:", error);
            setState(prev => ({ ...prev, isGenerating: false }));
            alert(error.message || "No se pudo generar el diagnóstico.");
        }
    };

    const handlePublish = async () => {
        if (!state.readiness.isValid) return;

        // Safety Valve: Check if we have real questions or if we are falling back to placeholders
        if (!state.context.prototypes || state.context.prototypes.length === 0) {
            const proceed = confirm("⚠️ No has generado preguntas con la IA aún.\n\nEl examen se creará con marcadores de posición (Placeholders). ¿Deseas continuar?");
            if (!proceed) return;
        }

        setState(prev => ({ ...prev, isGenerating: true }));
        try {
            const { publishExam } = await import("@/lib/actions/assessment/exam-actions");
            const result = await publishExam({
                title: examTitle,
                matrix: state.context,
                questions: state.context.prototypes as any[]
            }, {
                mode: 'auto_all' // Defaulting to Express Assignment for Standalone exams
            });
            if (result.success && result.url) {
                // alert(`Sonda de Calibración Desplegada. Topología Inmutable registrada.`);
                router.push(result.url);
                return result;
            } else {
                throw new Error(result.error || "Falla al publicar");
            }
        } catch (error: any) {
            console.error("[useArchitectActions] Publish error:", error);
            alert(error.message || "No se pudo publicar el examen.");
        } finally {
            setState(prev => ({ ...prev, isGenerating: false }));
        }
    };

    const handleReset = async () => {
        setIsLoading(true);
        try {
            const { resetDiscoveryContext } = await import("@/lib/actions/assessment/discovery-actions");
            const result = await resetDiscoveryContext();
            if (result.success) {
                setMessages([]);
                setState(INITIAL_ARCHITECT_STATE);
                setInput('');
            } else {
                throw new Error(result.error || "Falla al reiniciar");
            }
        } catch (error: any) {
            console.error("[useArchitectActions] Reset error:", error);
            alert(error.message || "No se pudo reiniciar la sesión.");
        } finally {
            setIsLoading(false);
        }
    };

    return {
        handleGeneratePrototypes,
        handleGenerate,
        handlePublish,
        handleReset
    };
}
